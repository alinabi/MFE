set include BOOL off .

fmod HF-SETS is
  protecting BOOL-OPS .
  sorts Magma Set .
  subsort Set < Magma .
  op _,_ : Magma Magma -> Magma [ctor assoc comm] .
  op {_} : Magma -> Set [ctor] .
  op {} : -> Set [ctor] .

  vars M M' : Magma .              vars S S' T : Set .

  eq [01]: M, M = M .

  op _in_ : Magma Set -> Bool .   *** set membership for several elements
  eq [11]: M in {} = false .
  eq [12]: S in {S'} = S ~ S' .
  eq [13]: S in {S', M} = (S ~ S') or (S in {M}) .
  eq [14]: S, M in {M'} = (S in {M'}) and (M in {M'}) .

  op _~_ : Set Set -> Bool .      *** set equality
  eq [21]: S ~ S' = (S <= S') and (S' <= S) .

  op _<=_ : Set Set -> Bool .     *** set containment
  eq [31]: {} <= S = true .
  eq [32]: {M} <= S = M in S .

  op _U_ : Set Set -> Set [assoc comm] .   *** union
  eq [41]: S U {} = S .
  eq [42]: {M} U {M'} = {M, M'} .
  eq [43]: S U {M} U {M'} = S U {M, M'} .

  op P : Set -> Set .          *** powerset
  eq [51]: P({}) = {{}} .
  eq [52]: P({S}) = {{},{S}} .
  eq [53]: P({S, M}) = P({M}) U augment(P({M}), S) .

  op augment : Set Set -> Set .
  eq [61]: augment({}, T) = {} .
  eq [62]: augment({S}, T) = {{T} U S} .
  eq [63]: augment({M, M'}, T) = augment({M}, T) U augment({M'}, T) .

  op _&_ : Set Set -> Set .       *** intersection
  eq [71]: {} & S = {} .
 ceq [72]: {S} & S' = {S} if S in S' = true .
 ceq [73]: {S} & S' = {} if S in S' = false .
 ceq [74]: {S, M} & S' = {S} U ({M} & S') if S in S' = true .
 ceq [75]: {S, M} & S' = {M} & S' if S in S' = false .
endfm
